## 实验仓库结构

**Arch-2022Sping-FDU**
├── build：仿真测试时才会生成的目录
├── difftest：仿真测试框架
├── ready-to-run：仿真测试文件目录
│　　├── lab1：包含lab1相关的测试文件，需要关注其中的 .S 汇编文件
│　　└── ...
├── vivado
│　　└── test1
│　　　　　└── project：vivado项目工程目录
├── vsrc：需要写的CPU代码所在目录
│　　├── include：头文件目录
│　　├── pipeline
│　　　　　├── regfile：寄存器文件目录，寄存器组模块已给出
│　　　　　├── execute：流水线执行阶段目录，alu模块已给出
│　　　　　└── core.sv：五级流水线主体代码
│　　├── ram：内存控制相关目录
│　　├── util：访存接口相关目录
│　　├── add_sources.tcl
│　　├── mycpu_top_nodelay.sv：以下是项目头文件
│　　├── mycpu_top.sv
│　　├── SimTop.sv
│　　└── VTop.sv
├── xpm_memory：Xilinx的内存IP
├── Makefile：仿真测试的命令汇总
└── readme.md: 此文件



## 实验环境介绍

> 请先阅读 实验环境搭建 并进行了实验环境的搭建

- verilator：我们采用 verilator 对CPU进行模拟（ verilator 要求运行在linux环境下，此外还需要安装一些库文件，具体可见 实验环境搭建），然后用 difftest 进行指令级别层面的对比，直接在仓库目录下执行 `make test-lab*` 即可。虽然verilator的仿真速度一般而言更快，但是功能还不完善，因此对我们编写代码有一定的限制（具体见 实验测试方法 中的代码编写部分）可以参考[去年实验的介绍](https://fducslg.github.io/ICS-2021Spring-FDU/misc/verilate.html)

- vivado：打开 vivado ，运行`vivado\test1\project\project_1.xpr`，点击 `tools` 选项下的`run tcl script`，运行 `vsrc\add_sources.tcl` 添加源文件后，就可以开始仿真、综合、生成bit文件上板了。

- Makefile：makefile可以简单理解为工程文件的编译规则，描述了整个工程的编译和链接等规则，内部具体的实现不需要了解，只需要知道通过 `make test-lab*`可以对对应的lab进行仿真测试即可

- git：我们采用 git 工具 对所有的 lab 进行管理并发布

  请先用 clone 命令下载我们的仓库的master，然后再下载difftest子仓库：

  ```bash
  git clone -b master https://github.com/FDUCSLG/Arch-2022Spring-FDU.git #我们的实验只需关注master这个分支
  cd Arch-2022Spring-FDU
  git submodule update --init --recursive
  ```

  其中的第一条命令的 `-b master` 指的是下载 master 这个分支，我们的实验只需要关注 master 分支，所以其它的分支可以不下载。

  此外我们会不定时地更新代码仓库以解决bug（因此必须用clone把仓库配置相关文件也下载下来，这样才方便进行后续更新），每次更新的时候助教都会在群里或者上课的时候进行提醒，当然更好的是养成每次写代码前及时更新的习惯 :smirk: 。以下是更新的步骤：

  ```bash
  # 先在vsrc目录下提交保存你写的代码
  cd vsrc
  git add .
  git commit -m "本此提交的信息，比如：commit for pull"
  
  # 然后运行以下命令拉取并合并远端仓库的代码
  git pull origin master # 我们的实验只需关注master分支
  # 可能会有冲突，因人而异，需要自行解决
  git submodule update #更新子仓库
  ```

  git 的功能十分强大，这里所用的不及九牛一毛，如果你感兴趣的话可以自行搜索。

- GTKWave：开源的波形图浏览器，在`make`命令后加上 `VOPT="--dump-wave"`即可在 build 目录下看到 fst 格式的波形图，可以参考[去年实验的介绍](https://fducslg.github.io/ICS-2021Spring-FDU/misc/gtkwave.html)。





## 实验框架介绍

> 请先阅读 实验测试方法 

### CPU 访存接口

流水线部分有指令内存接口与数据内存接口，CPU与内存的交互**只需要**这两个接口，定义在 `include/common.sv` ; 实现在 `core.sv` 的`input`和`output`接口

指令内存接口：

```verilog
typedef struct packed {
    logic  valid;  // in request? (Used in Lab 2)
    addr_t addr;   // target address
} ibus_req_t;

typedef struct packed {
    logic  addr_ok;  // is the address accepted by cache? (Used in Lab 2)
    logic  data_ok;  // is the field "data" valid?		  (Used in Lab 2)
    u32 data;        // the data read from cache
} ibus_resp_t;
```

数据内存接口：

```verilog
typedef struct packed {
    logic    valid;   // in request?
    addr_t   addr;    // target address
    msize_t  size;    // number of bytes				(Used in Lab 2)
    strobe_t strobe;  // which bytes are enabled? set to zeros for read request (in Lab 1, it is either '0 or '1)
    word_t   data;    // the data to write
} dbus_req_t;
 
typedef struct packed {
    logic  addr_ok;  // is the address accepted by cache?	(Used in Lab 2)
    logic  data_ok;  // is the field "data" valid?			(Used in Lab 2)
    word_t data;     // the data read from cache
} dbus_resp_t;
```

### include与import

对于verilator，引用其它文件定义的结构或是模块都需要进行`include`

```verilog
`ifdef VERILATOR
`include "文件相对于vsrc的路径"
`else
`endif
```

比如在`core.sv`中，不仅使用到了定义在`common.sv`中的`ibus`和`dbus`，如果也用到了`regfile.sv`中定义的`regfile`模块，那么**都需要**进行`include`：

```verilog
`ifdef VERILATOR
`include "include/common.sv"
`include "pipeline/regfile/regfile.sv"
`else
`endif
```

而对于vivado，为了引用其它结构，需要在每个模块内`import`对应的package，但是使用其它文件定义的模块则不需要`import`，使用tcl脚本加入源文件后，vivado会自行找到，比如`core.sv`中

```verilog
module core
    import common::*;(
		input logic clk, reset,
		output ibus_req_t  ireq,
		...
    );
endmodule
```

`import`了定义在`common.sv`中的名叫 `common` 的package，但是不需要`import regfile`，直接使用即可。

```verilog
package common;
    ....
endpackage
```

### 接入Verilator仿真

将 CPU 接入 Verilator Difftest 的仿真接口。

需要例化三个模块（所给框架中已例化好，需要接线）。

首先是当前周期提交的指令：

```verilog
DifftestInstrCommit DifftestInstrCommit(
    .clock              (clk),
    .coreid             (0), // 无需改动
    .index              (0), // 多发射时，例化多个该模块。前四个 Lab 无需改动它
    .valid              (0), // 无提交（或提交的指令是flush导致的bubble时，为0）
    .pc                 (0), // 这条指令的 pc
    .instr              (0), // 这条指令的内容，可不改动
    .skip               (0), // 提交的是一条内存读写指令，且这部分内存属于设备（addr[31] == 0）时，skip为1
    .isRVC              (0), // 前四个 Lab 无需改动
    .scFailed           (0), // 前四个 Lab 无需改动
    .wen                (0), // 这条指令是否写入通用寄存器，1 bit
    .wdest              (0), // 写入哪个通用寄存器
    .wdata              (0)  // 写入的值
);
```

这个周期的指令提交后，通用寄存器的内容（已连接好）：

```verilog
DifftestArchIntRegState DifftestArchIntRegState (
    .clock              (clk),
    .coreid             (0),
    .gpr_0              (regfile.regs_nxt[0]),
    // ...
);
```

这个周期的指令提交后，系统寄存器的内容（Lab4 的内容，前面的 Lab 可以不管）：

```verilog
DifftestCSRState DifftestCSRState(

);
```

### 生成波形图

不生成波形图时运行测试，使用`make test-lab1`；需要生成波形图，使用 `make test-lab1 VOPT="--dump-wave"`，运行结束后可在 `build` 目录下看到波形图，使用 gtkwave 打开。

默认截取前 $10^6$ 个时钟周期。如果需要调整，使用 `make test-lab1 VOPT="--dump-wave -b <begin> -e <end>"`。



## 如何提问

我们非常愿意帮助大家高效解决问题，同时又希望大家能抓住每一次锻炼自己善用各种资源以及获得意外惊喜的机会。因此我们给出以下几点建议，更完整的部分可以在 [提问的智慧](https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md) 中仔细阅读：

1. 请确保在有充足时间的情况下善用搜索引擎、网站资料以及交流平台等资源，看看是否其他人也遇到了类似的问题，并进行解决问题的尝试。
2. 首先说明你所使用的平台以及版本，如 WSL / MacOS / Linux等。
3. 用尽可能简短但是清晰的语言描述你所遇到的问题，从核心问题出发，补充说明需要的前置背景即可。
4. 可以说明自己尝试过的搏斗，可能但是由于各种原因没有尝试的想法等，运用经验解决问题有时需要发挥想象力。

同时，我们非常欢迎同学们一起帮助陷入瓶颈的同学（~~助教也是过来人~~），帮助其他人排除障碍绝非浪费时间，而是一种教学相长！



## 一些题外话

1. 我们不鼓励内卷，真心希望大家能通过这门课学习到计算机组成与体系结构相关的知识。
2. 当然只要是学生就都会关心成绩，所以助教在此向大家声明，只要用心学，成绩一定不会差 :)，敷衍了事者自是自食其果。
3. 若有任何关于课堂或是课程的想法，都很欢迎联系老师或助教提出，slack / 微信 / 邮箱均可，我们会认真回复。
4. 祝同学们这一学期过的充实愉快，学有所成~！